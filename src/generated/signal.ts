// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.8.3
//   protoc               v5.29.3
// source: signal.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import type { CallContext, CallOptions } from "nice-grpc-common";

export const protobufPackage = "signal_scope";

export interface DataPoint {
  x: number;
  y: number;
}

export interface SignalResponse {
  input: DataPoint[];
  transmitted: DataPoint[];
  output: DataPoint[];
}

export interface AnalogToAnalogRequest {
  messageFrequency: number;
  messageAmplitude: number;
  algorithm: AnalogToAnalogRequest_Algorithm;
}

export enum AnalogToAnalogRequest_Algorithm {
  AM = 0,
  FM = 1,
  PM = 2,
  UNRECOGNIZED = -1,
}

export function analogToAnalogRequest_AlgorithmFromJSON(object: any): AnalogToAnalogRequest_Algorithm {
  switch (object) {
    case 0:
    case "AM":
      return AnalogToAnalogRequest_Algorithm.AM;
    case 1:
    case "FM":
      return AnalogToAnalogRequest_Algorithm.FM;
    case 2:
    case "PM":
      return AnalogToAnalogRequest_Algorithm.PM;
    case -1:
    case "UNRECOGNIZED":
    default:
      return AnalogToAnalogRequest_Algorithm.UNRECOGNIZED;
  }
}

export function analogToAnalogRequest_AlgorithmToJSON(object: AnalogToAnalogRequest_Algorithm): string {
  switch (object) {
    case AnalogToAnalogRequest_Algorithm.AM:
      return "AM";
    case AnalogToAnalogRequest_Algorithm.FM:
      return "FM";
    case AnalogToAnalogRequest_Algorithm.PM:
      return "PM";
    case AnalogToAnalogRequest_Algorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface AnalogToDigitalRequest {
  frequency: number;
  amplitude: number;
  pcm?: AnalogToDigitalRequest_PCMConfig | undefined;
  deltaModulation?: AnalogToDigitalRequest_DeltaModulationConfig | undefined;
}

export interface AnalogToDigitalRequest_PCMConfig {
  samplingRate: number;
  quantizationLevels: number;
}

export interface AnalogToDigitalRequest_DeltaModulationConfig {
  samplingRate: number;
  deltaStepSize: number;
}

export interface DigitalToAnalogRequest {
  binaryInput: string;
  algorithm: DigitalToAnalogRequest_Algorithm;
}

export enum DigitalToAnalogRequest_Algorithm {
  ASK = 0,
  FSK = 1,
  PSK = 2,
  UNRECOGNIZED = -1,
}

export function digitalToAnalogRequest_AlgorithmFromJSON(object: any): DigitalToAnalogRequest_Algorithm {
  switch (object) {
    case 0:
    case "ASK":
      return DigitalToAnalogRequest_Algorithm.ASK;
    case 1:
    case "FSK":
      return DigitalToAnalogRequest_Algorithm.FSK;
    case 2:
    case "PSK":
      return DigitalToAnalogRequest_Algorithm.PSK;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DigitalToAnalogRequest_Algorithm.UNRECOGNIZED;
  }
}

export function digitalToAnalogRequest_AlgorithmToJSON(object: DigitalToAnalogRequest_Algorithm): string {
  switch (object) {
    case DigitalToAnalogRequest_Algorithm.ASK:
      return "ASK";
    case DigitalToAnalogRequest_Algorithm.FSK:
      return "FSK";
    case DigitalToAnalogRequest_Algorithm.PSK:
      return "PSK";
    case DigitalToAnalogRequest_Algorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface DigitalToDigitalRequest {
  binaryInput: string;
  algorithm: DigitalToDigitalRequest_Algorithm;
}

export enum DigitalToDigitalRequest_Algorithm {
  NRZ_L = 0,
  NRZ_I = 1,
  MANCHESTER = 2,
  DIFFERENTIAL_MANCHESTER = 3,
  AMI = 4,
  PSEUDOTERNARY = 5,
  B8ZS = 6,
  HDB3 = 7,
  UNRECOGNIZED = -1,
}

export function digitalToDigitalRequest_AlgorithmFromJSON(object: any): DigitalToDigitalRequest_Algorithm {
  switch (object) {
    case 0:
    case "NRZ_L":
      return DigitalToDigitalRequest_Algorithm.NRZ_L;
    case 1:
    case "NRZ_I":
      return DigitalToDigitalRequest_Algorithm.NRZ_I;
    case 2:
    case "MANCHESTER":
      return DigitalToDigitalRequest_Algorithm.MANCHESTER;
    case 3:
    case "DIFFERENTIAL_MANCHESTER":
      return DigitalToDigitalRequest_Algorithm.DIFFERENTIAL_MANCHESTER;
    case 4:
    case "AMI":
      return DigitalToDigitalRequest_Algorithm.AMI;
    case 5:
    case "PSEUDOTERNARY":
      return DigitalToDigitalRequest_Algorithm.PSEUDOTERNARY;
    case 6:
    case "B8ZS":
      return DigitalToDigitalRequest_Algorithm.B8ZS;
    case 7:
    case "HDB3":
      return DigitalToDigitalRequest_Algorithm.HDB3;
    case -1:
    case "UNRECOGNIZED":
    default:
      return DigitalToDigitalRequest_Algorithm.UNRECOGNIZED;
  }
}

export function digitalToDigitalRequest_AlgorithmToJSON(object: DigitalToDigitalRequest_Algorithm): string {
  switch (object) {
    case DigitalToDigitalRequest_Algorithm.NRZ_L:
      return "NRZ_L";
    case DigitalToDigitalRequest_Algorithm.NRZ_I:
      return "NRZ_I";
    case DigitalToDigitalRequest_Algorithm.MANCHESTER:
      return "MANCHESTER";
    case DigitalToDigitalRequest_Algorithm.DIFFERENTIAL_MANCHESTER:
      return "DIFFERENTIAL_MANCHESTER";
    case DigitalToDigitalRequest_Algorithm.AMI:
      return "AMI";
    case DigitalToDigitalRequest_Algorithm.PSEUDOTERNARY:
      return "PSEUDOTERNARY";
    case DigitalToDigitalRequest_Algorithm.B8ZS:
      return "B8ZS";
    case DigitalToDigitalRequest_Algorithm.HDB3:
      return "HDB3";
    case DigitalToDigitalRequest_Algorithm.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

function createBaseDataPoint(): DataPoint {
  return { x: 0, y: 0 };
}

export const DataPoint: MessageFns<DataPoint> = {
  encode(message: DataPoint, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.x !== 0) {
      writer.uint32(9).double(message.x);
    }
    if (message.y !== 0) {
      writer.uint32(17).double(message.y);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DataPoint {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDataPoint();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.x = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.y = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DataPoint {
    return {
      x: isSet(object.x) ? globalThis.Number(object.x) : 0,
      y: isSet(object.y) ? globalThis.Number(object.y) : 0,
    };
  },

  toJSON(message: DataPoint): unknown {
    const obj: any = {};
    if (message.x !== 0) {
      obj.x = message.x;
    }
    if (message.y !== 0) {
      obj.y = message.y;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DataPoint>, I>>(base?: I): DataPoint {
    return DataPoint.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DataPoint>, I>>(object: I): DataPoint {
    const message = createBaseDataPoint();
    message.x = object.x ?? 0;
    message.y = object.y ?? 0;
    return message;
  },
};

function createBaseSignalResponse(): SignalResponse {
  return { input: [], transmitted: [], output: [] };
}

export const SignalResponse: MessageFns<SignalResponse> = {
  encode(message: SignalResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.input) {
      DataPoint.encode(v!, writer.uint32(10).fork()).join();
    }
    for (const v of message.transmitted) {
      DataPoint.encode(v!, writer.uint32(18).fork()).join();
    }
    for (const v of message.output) {
      DataPoint.encode(v!, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SignalResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSignalResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.input.push(DataPoint.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.transmitted.push(DataPoint.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.output.push(DataPoint.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SignalResponse {
    return {
      input: globalThis.Array.isArray(object?.input) ? object.input.map((e: any) => DataPoint.fromJSON(e)) : [],
      transmitted: globalThis.Array.isArray(object?.transmitted)
        ? object.transmitted.map((e: any) => DataPoint.fromJSON(e))
        : [],
      output: globalThis.Array.isArray(object?.output) ? object.output.map((e: any) => DataPoint.fromJSON(e)) : [],
    };
  },

  toJSON(message: SignalResponse): unknown {
    const obj: any = {};
    if (message.input?.length) {
      obj.input = message.input.map((e) => DataPoint.toJSON(e));
    }
    if (message.transmitted?.length) {
      obj.transmitted = message.transmitted.map((e) => DataPoint.toJSON(e));
    }
    if (message.output?.length) {
      obj.output = message.output.map((e) => DataPoint.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SignalResponse>, I>>(base?: I): SignalResponse {
    return SignalResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SignalResponse>, I>>(object: I): SignalResponse {
    const message = createBaseSignalResponse();
    message.input = object.input?.map((e) => DataPoint.fromPartial(e)) || [];
    message.transmitted = object.transmitted?.map((e) => DataPoint.fromPartial(e)) || [];
    message.output = object.output?.map((e) => DataPoint.fromPartial(e)) || [];
    return message;
  },
};

function createBaseAnalogToAnalogRequest(): AnalogToAnalogRequest {
  return { messageFrequency: 0, messageAmplitude: 0, algorithm: 0 };
}

export const AnalogToAnalogRequest: MessageFns<AnalogToAnalogRequest> = {
  encode(message: AnalogToAnalogRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.messageFrequency !== 0) {
      writer.uint32(9).double(message.messageFrequency);
    }
    if (message.messageAmplitude !== 0) {
      writer.uint32(17).double(message.messageAmplitude);
    }
    if (message.algorithm !== 0) {
      writer.uint32(24).int32(message.algorithm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalogToAnalogRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalogToAnalogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.messageFrequency = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.messageAmplitude = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalogToAnalogRequest {
    return {
      messageFrequency: isSet(object.messageFrequency) ? globalThis.Number(object.messageFrequency) : 0,
      messageAmplitude: isSet(object.messageAmplitude) ? globalThis.Number(object.messageAmplitude) : 0,
      algorithm: isSet(object.algorithm) ? analogToAnalogRequest_AlgorithmFromJSON(object.algorithm) : 0,
    };
  },

  toJSON(message: AnalogToAnalogRequest): unknown {
    const obj: any = {};
    if (message.messageFrequency !== 0) {
      obj.messageFrequency = message.messageFrequency;
    }
    if (message.messageAmplitude !== 0) {
      obj.messageAmplitude = message.messageAmplitude;
    }
    if (message.algorithm !== 0) {
      obj.algorithm = analogToAnalogRequest_AlgorithmToJSON(message.algorithm);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalogToAnalogRequest>, I>>(base?: I): AnalogToAnalogRequest {
    return AnalogToAnalogRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalogToAnalogRequest>, I>>(object: I): AnalogToAnalogRequest {
    const message = createBaseAnalogToAnalogRequest();
    message.messageFrequency = object.messageFrequency ?? 0;
    message.messageAmplitude = object.messageAmplitude ?? 0;
    message.algorithm = object.algorithm ?? 0;
    return message;
  },
};

function createBaseAnalogToDigitalRequest(): AnalogToDigitalRequest {
  return { frequency: 0, amplitude: 0, pcm: undefined, deltaModulation: undefined };
}

export const AnalogToDigitalRequest: MessageFns<AnalogToDigitalRequest> = {
  encode(message: AnalogToDigitalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.frequency !== 0) {
      writer.uint32(9).double(message.frequency);
    }
    if (message.amplitude !== 0) {
      writer.uint32(17).double(message.amplitude);
    }
    if (message.pcm !== undefined) {
      AnalogToDigitalRequest_PCMConfig.encode(message.pcm, writer.uint32(26).fork()).join();
    }
    if (message.deltaModulation !== undefined) {
      AnalogToDigitalRequest_DeltaModulationConfig.encode(message.deltaModulation, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalogToDigitalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalogToDigitalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.frequency = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.amplitude = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.pcm = AnalogToDigitalRequest_PCMConfig.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.deltaModulation = AnalogToDigitalRequest_DeltaModulationConfig.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalogToDigitalRequest {
    return {
      frequency: isSet(object.frequency) ? globalThis.Number(object.frequency) : 0,
      amplitude: isSet(object.amplitude) ? globalThis.Number(object.amplitude) : 0,
      pcm: isSet(object.pcm) ? AnalogToDigitalRequest_PCMConfig.fromJSON(object.pcm) : undefined,
      deltaModulation: isSet(object.deltaModulation)
        ? AnalogToDigitalRequest_DeltaModulationConfig.fromJSON(object.deltaModulation)
        : undefined,
    };
  },

  toJSON(message: AnalogToDigitalRequest): unknown {
    const obj: any = {};
    if (message.frequency !== 0) {
      obj.frequency = message.frequency;
    }
    if (message.amplitude !== 0) {
      obj.amplitude = message.amplitude;
    }
    if (message.pcm !== undefined) {
      obj.pcm = AnalogToDigitalRequest_PCMConfig.toJSON(message.pcm);
    }
    if (message.deltaModulation !== undefined) {
      obj.deltaModulation = AnalogToDigitalRequest_DeltaModulationConfig.toJSON(message.deltaModulation);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalogToDigitalRequest>, I>>(base?: I): AnalogToDigitalRequest {
    return AnalogToDigitalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalogToDigitalRequest>, I>>(object: I): AnalogToDigitalRequest {
    const message = createBaseAnalogToDigitalRequest();
    message.frequency = object.frequency ?? 0;
    message.amplitude = object.amplitude ?? 0;
    message.pcm = (object.pcm !== undefined && object.pcm !== null)
      ? AnalogToDigitalRequest_PCMConfig.fromPartial(object.pcm)
      : undefined;
    message.deltaModulation = (object.deltaModulation !== undefined && object.deltaModulation !== null)
      ? AnalogToDigitalRequest_DeltaModulationConfig.fromPartial(object.deltaModulation)
      : undefined;
    return message;
  },
};

function createBaseAnalogToDigitalRequest_PCMConfig(): AnalogToDigitalRequest_PCMConfig {
  return { samplingRate: 0, quantizationLevels: 0 };
}

export const AnalogToDigitalRequest_PCMConfig: MessageFns<AnalogToDigitalRequest_PCMConfig> = {
  encode(message: AnalogToDigitalRequest_PCMConfig, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.samplingRate !== 0) {
      writer.uint32(9).double(message.samplingRate);
    }
    if (message.quantizationLevels !== 0) {
      writer.uint32(16).int32(message.quantizationLevels);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalogToDigitalRequest_PCMConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalogToDigitalRequest_PCMConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.samplingRate = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantizationLevels = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalogToDigitalRequest_PCMConfig {
    return {
      samplingRate: isSet(object.samplingRate) ? globalThis.Number(object.samplingRate) : 0,
      quantizationLevels: isSet(object.quantizationLevels) ? globalThis.Number(object.quantizationLevels) : 0,
    };
  },

  toJSON(message: AnalogToDigitalRequest_PCMConfig): unknown {
    const obj: any = {};
    if (message.samplingRate !== 0) {
      obj.samplingRate = message.samplingRate;
    }
    if (message.quantizationLevels !== 0) {
      obj.quantizationLevels = Math.round(message.quantizationLevels);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalogToDigitalRequest_PCMConfig>, I>>(
    base?: I,
  ): AnalogToDigitalRequest_PCMConfig {
    return AnalogToDigitalRequest_PCMConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalogToDigitalRequest_PCMConfig>, I>>(
    object: I,
  ): AnalogToDigitalRequest_PCMConfig {
    const message = createBaseAnalogToDigitalRequest_PCMConfig();
    message.samplingRate = object.samplingRate ?? 0;
    message.quantizationLevels = object.quantizationLevels ?? 0;
    return message;
  },
};

function createBaseAnalogToDigitalRequest_DeltaModulationConfig(): AnalogToDigitalRequest_DeltaModulationConfig {
  return { samplingRate: 0, deltaStepSize: 0 };
}

export const AnalogToDigitalRequest_DeltaModulationConfig: MessageFns<AnalogToDigitalRequest_DeltaModulationConfig> = {
  encode(
    message: AnalogToDigitalRequest_DeltaModulationConfig,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.samplingRate !== 0) {
      writer.uint32(9).double(message.samplingRate);
    }
    if (message.deltaStepSize !== 0) {
      writer.uint32(17).double(message.deltaStepSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AnalogToDigitalRequest_DeltaModulationConfig {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAnalogToDigitalRequest_DeltaModulationConfig();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 9) {
            break;
          }

          message.samplingRate = reader.double();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.deltaStepSize = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AnalogToDigitalRequest_DeltaModulationConfig {
    return {
      samplingRate: isSet(object.samplingRate) ? globalThis.Number(object.samplingRate) : 0,
      deltaStepSize: isSet(object.deltaStepSize) ? globalThis.Number(object.deltaStepSize) : 0,
    };
  },

  toJSON(message: AnalogToDigitalRequest_DeltaModulationConfig): unknown {
    const obj: any = {};
    if (message.samplingRate !== 0) {
      obj.samplingRate = message.samplingRate;
    }
    if (message.deltaStepSize !== 0) {
      obj.deltaStepSize = message.deltaStepSize;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AnalogToDigitalRequest_DeltaModulationConfig>, I>>(
    base?: I,
  ): AnalogToDigitalRequest_DeltaModulationConfig {
    return AnalogToDigitalRequest_DeltaModulationConfig.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AnalogToDigitalRequest_DeltaModulationConfig>, I>>(
    object: I,
  ): AnalogToDigitalRequest_DeltaModulationConfig {
    const message = createBaseAnalogToDigitalRequest_DeltaModulationConfig();
    message.samplingRate = object.samplingRate ?? 0;
    message.deltaStepSize = object.deltaStepSize ?? 0;
    return message;
  },
};

function createBaseDigitalToAnalogRequest(): DigitalToAnalogRequest {
  return { binaryInput: "", algorithm: 0 };
}

export const DigitalToAnalogRequest: MessageFns<DigitalToAnalogRequest> = {
  encode(message: DigitalToAnalogRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.binaryInput !== "") {
      writer.uint32(10).string(message.binaryInput);
    }
    if (message.algorithm !== 0) {
      writer.uint32(16).int32(message.algorithm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DigitalToAnalogRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDigitalToAnalogRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.binaryInput = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DigitalToAnalogRequest {
    return {
      binaryInput: isSet(object.binaryInput) ? globalThis.String(object.binaryInput) : "",
      algorithm: isSet(object.algorithm) ? digitalToAnalogRequest_AlgorithmFromJSON(object.algorithm) : 0,
    };
  },

  toJSON(message: DigitalToAnalogRequest): unknown {
    const obj: any = {};
    if (message.binaryInput !== "") {
      obj.binaryInput = message.binaryInput;
    }
    if (message.algorithm !== 0) {
      obj.algorithm = digitalToAnalogRequest_AlgorithmToJSON(message.algorithm);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DigitalToAnalogRequest>, I>>(base?: I): DigitalToAnalogRequest {
    return DigitalToAnalogRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DigitalToAnalogRequest>, I>>(object: I): DigitalToAnalogRequest {
    const message = createBaseDigitalToAnalogRequest();
    message.binaryInput = object.binaryInput ?? "";
    message.algorithm = object.algorithm ?? 0;
    return message;
  },
};

function createBaseDigitalToDigitalRequest(): DigitalToDigitalRequest {
  return { binaryInput: "", algorithm: 0 };
}

export const DigitalToDigitalRequest: MessageFns<DigitalToDigitalRequest> = {
  encode(message: DigitalToDigitalRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.binaryInput !== "") {
      writer.uint32(10).string(message.binaryInput);
    }
    if (message.algorithm !== 0) {
      writer.uint32(16).int32(message.algorithm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DigitalToDigitalRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    const end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDigitalToDigitalRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.binaryInput = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.algorithm = reader.int32() as any;
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DigitalToDigitalRequest {
    return {
      binaryInput: isSet(object.binaryInput) ? globalThis.String(object.binaryInput) : "",
      algorithm: isSet(object.algorithm) ? digitalToDigitalRequest_AlgorithmFromJSON(object.algorithm) : 0,
    };
  },

  toJSON(message: DigitalToDigitalRequest): unknown {
    const obj: any = {};
    if (message.binaryInput !== "") {
      obj.binaryInput = message.binaryInput;
    }
    if (message.algorithm !== 0) {
      obj.algorithm = digitalToDigitalRequest_AlgorithmToJSON(message.algorithm);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DigitalToDigitalRequest>, I>>(base?: I): DigitalToDigitalRequest {
    return DigitalToDigitalRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DigitalToDigitalRequest>, I>>(object: I): DigitalToDigitalRequest {
    const message = createBaseDigitalToDigitalRequest();
    message.binaryInput = object.binaryInput ?? "";
    message.algorithm = object.algorithm ?? 0;
    return message;
  },
};

export interface SignalConversionServiceImplementation<CallContextExt = {}> {
  analogToAnalog(
    request: AnalogToAnalogRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SignalResponse>>;
  analogToDigital(
    request: AnalogToDigitalRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SignalResponse>>;
  digitalToAnalog(
    request: DigitalToAnalogRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SignalResponse>>;
  digitalToDigital(
    request: DigitalToDigitalRequest,
    context: CallContext & CallContextExt,
  ): Promise<DeepPartial<SignalResponse>>;
}

export interface SignalConversionClient<CallOptionsExt = {}> {
  analogToAnalog(
    request: DeepPartial<AnalogToAnalogRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SignalResponse>;
  analogToDigital(
    request: DeepPartial<AnalogToDigitalRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SignalResponse>;
  digitalToAnalog(
    request: DeepPartial<DigitalToAnalogRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SignalResponse>;
  digitalToDigital(
    request: DeepPartial<DigitalToDigitalRequest>,
    options?: CallOptions & CallOptionsExt,
  ): Promise<SignalResponse>;
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
